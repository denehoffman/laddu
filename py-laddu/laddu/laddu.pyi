from pathlib import Path
from typing import Any, Sequence

def version() -> str: ...
def available_parallelism() -> int: ...


class Evaluator: ...


class Expression: ...


class ParameterLike: ...


def TestAmplitude(name: str, re: ParameterLike, im: ParameterLike) -> Expression: ...


def One() -> Expression: ...
def Zero() -> Expression: ...
def expr_product(amplitudes: Sequence[Expression]) -> Expression: ...
def expr_sum(amplitudes: Sequence[Expression]) -> Expression: ...
def constant(value: float) -> ParameterLike: ...
def parameter(name: str) -> ParameterLike: ...


def BreitWigner(*args: Any, **kwargs: Any) -> Expression: ...
def ComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PolarComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def Scalar(*args: Any, **kwargs: Any) -> Expression: ...
def PhaseSpaceFactor(*args: Any, **kwargs: Any) -> Expression: ...
def Ylm(*args: Any, **kwargs: Any) -> Expression: ...
def PolPhase(*args: Any, **kwargs: Any) -> Expression: ...
def Zlm(*args: Any, **kwargs: Any) -> Expression: ...


def KopfKMatrixA0(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixA2(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixF0(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixF2(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixPi1(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixRho(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewiseScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewiseComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewisePolarComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...


class VariableExpression: ...


class BinnedDataset: ...


class Dataset:
    def __init__(
        self,
        events: list[Event],
        *,
        p4_names: list[str] | None = ...,
        aux_names: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> None: ...
    @staticmethod
    def open(
        path: str | Path,
        *,
        p4s: list[str] | None = ...,
        aux: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
        backend: str | None = ...,
        tree: str | None = ...,
        uproot_kwargs: dict[str, Any] | None = ...,
        amptools_kwargs: dict[str, Any] | None = ...,
    ) -> Dataset: ...


class Event:
    def __init__(
        self,
        p4s: list[Any],
        aux: list[float],
        weight: float,
        *,
        p4_names: list[str] | None = ...,
        aux_names: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> None: ...


class NLL: ...


class AutocorrelationTerminator: ...


class ControlFlow: ...


class EnsembleStatus: ...


class LikelihoodEvaluator: ...


class LikelihoodExpression: ...


class LikelihoodID: ...


class LikelihoodManager: ...


class LikelihoodOne: ...


class LikelihoodScalar: ...


class LikelihoodTerm: ...


class LikelihoodZero: ...


class MCMCObserver: ...


class MCMCSummary: ...


class MCMCTerminator: ...


class MinimizationObserver: ...


class MinimizationStatus: ...


class MinimizationSummary: ...


class MinimizationTerminator: ...


class StochasticNLL: ...


class Swarm: ...


class SwarmParticle: ...


class Walker: ...


def integrated_autocorrelation_times(*args: Any, **kwargs: Any) -> Any: ...
def likelihood_product(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...
def likelihood_sum(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...


class Angles: ...


class CosTheta: ...


class Mandelstam: ...


class Mass: ...


class Phi: ...


class PolAngle: ...


class PolMagnitude: ...


class Polarization: ...


class Topology: ...


class Vec3: ...


class Vec4: ...


def BinnedGuideTerm(*args: Any, **kwargs: Any) -> LikelihoodTerm: ...
def Regularizer(*args: Any, **kwargs: Any) -> LikelihoodTerm: ...


def finalize_mpi() -> None: ...
def get_rank() -> int: ...
def get_size() -> int: ...
def is_mpi_available() -> bool: ...
def is_root() -> bool: ...
def use_mpi(trigger: bool = ...) -> None: ...
def using_mpi() -> bool: ...
