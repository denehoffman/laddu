from pathlib import Path
from typing import Any, Iterator, Sequence

def version() -> str: ...
def available_parallelism() -> int: ...

class Evaluator: ...
class Expression: ...
class ParameterLike: ...

def TestAmplitude(name: str, re: ParameterLike, im: ParameterLike) -> Expression: ...
def One() -> Expression: ...
def Zero() -> Expression: ...
def expr_product(amplitudes: Sequence[Expression]) -> Expression: ...
def expr_sum(amplitudes: Sequence[Expression]) -> Expression: ...
def constant(name: str, value: float) -> ParameterLike: ...
def parameter(name: str, value: float | None = ...) -> ParameterLike: ...
def BreitWigner(*args: Any, **kwargs: Any) -> Expression: ...
def ComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PolarComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def Scalar(*args: Any, **kwargs: Any) -> Expression: ...
def PhaseSpaceFactor(*args: Any, **kwargs: Any) -> Expression: ...
def Ylm(*args: Any, **kwargs: Any) -> Expression: ...
def PolPhase(*args: Any, **kwargs: Any) -> Expression: ...
def Zlm(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixA0(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixA2(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixF0(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixF2(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixPi1(*args: Any, **kwargs: Any) -> Expression: ...
def KopfKMatrixRho(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewiseScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewiseComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...
def PiecewisePolarComplexScalar(*args: Any, **kwargs: Any) -> Expression: ...

class VariableExpression: ...
class BinnedDataset: ...

class Dataset(Sequence[Event]):
    p4_names: list[str]
    aux_names: list[str]

    def __init__(
        self,
        events: list[Event],
        *,
        p4_names: list[str] | None = ...,
        aux_names: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Event]: ...
    @staticmethod
    def from_parquet(
        path: str | Path,
        *,
        p4s: list[str] | None = ...,
        aux: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> Dataset: ...
    @staticmethod
    def from_root(
        path: str | Path,
        *,
        tree: str | None = ...,
        p4s: list[str] | None = ...,
        aux: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> Dataset: ...
    @staticmethod
    def from_amptools(
        path: str | Path,
        *,
        tree: str | None = ...,
        pol_in_beam: bool = ...,
        pol_angle: float | None = ...,
        pol_magnitude: float | None = ...,
        pol_magnitude_name: str = ...,
        pol_angle_name: str = ...,
        num_entries: int | None = ...,
    ) -> Dataset: ...
    def to_parquet(
        self,
        path: str | Path,
        *,
        chunk_size: int | None = ...,
        precision: str = ...,
    ) -> None: ...
    def to_root(
        self,
        path: str | Path,
        *,
        tree: str | None = ...,
        chunk_size: int | None = ...,
        precision: str = ...,
    ) -> None: ...

class Event:
    p4s: Any
    aux: Any
    weight: float

    def __init__(
        self,
        p4s: list[Any],
        aux: list[float],
        weight: float,
        *,
        p4_names: list[str] | None = ...,
        aux_names: list[str] | None = ...,
        aliases: dict[str, str | list[str]] | None = ...,
    ) -> None: ...

class NLL: ...
class AutocorrelationTerminator: ...
class ControlFlow: ...
class EnsembleStatus: ...
class LikelihoodEvaluator: ...
class LikelihoodExpression: ...
class LikelihoodOne: ...
class LikelihoodScalar: ...
class LikelihoodZero: ...
class MCMCObserver: ...
class MCMCSummary: ...
class MCMCTerminator: ...
class MinimizationObserver: ...
class MinimizationStatus: ...
class MinimizationSummary: ...
class MinimizationTerminator: ...
class StochasticNLL: ...
class Swarm: ...
class SwarmParticle: ...
class Walker: ...

def integrated_autocorrelation_times(*args: Any, **kwargs: Any) -> Any: ...
def likelihood_product(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...
def likelihood_sum(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...

class Angles: ...
class CosTheta: ...
class Mandelstam: ...
class Mass: ...
class Phi: ...
class PolAngle: ...
class PolMagnitude: ...
class Polarization: ...
class Topology: ...
class Vec3: ...
class Vec4: ...

def BinnedGuideTerm(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...
def Regularizer(*args: Any, **kwargs: Any) -> LikelihoodExpression: ...
def finalize_mpi() -> None: ...
def get_rank() -> int: ...
def get_size() -> int: ...
def is_mpi_available() -> bool: ...
def is_root() -> bool: ...
def use_mpi(trigger: bool = ...) -> None: ...
def using_mpi() -> bool: ...
